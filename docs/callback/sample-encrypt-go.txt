package main

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"fmt"
	"io"
)

// ===== PKCS7 =====
func pad(src []byte) []byte {
	padding := aes.BlockSize - len(src)%aes.BlockSize
	padtext := bytes.Repeat([]byte{byte(padding)}, padding)
	return append(src, padtext...)
}

func unpad(src []byte) []byte {
	length := len(src)
	unpadding := int(src[length-1])
	return src[:(length - unpadding)]
}

// ===== Key from API key =====
func hashKey(apiKey string) []byte {
	hash := sha256.Sum256([]byte(apiKey))
	return hash[:]
}

// ===== ENCRYPT =====
func Encrypt(text, apiKey string) (string, error) {
	key := hashKey(apiKey)

	block, err := aes.NewCipher(key)
	if err != nil {
		return "", err
	}

	plain := pad([]byte(text))
	ciphertext := make([]byte, aes.BlockSize+len(plain))

	iv := ciphertext[:aes.BlockSize]
	if _, err := io.ReadFull(rand.Reader, iv); err != nil {
		return "", err
	}

	mode := cipher.NewCBCEncrypter(block, iv)
	mode.CryptBlocks(ciphertext[aes.BlockSize:], plain)

	return base64.StdEncoding.EncodeToString(ciphertext), nil
}

// ===== DECRYPT =====
func Decrypt(enc string, apiKey string) (string, error) {
	key := hashKey(apiKey)

	data, err := base64.StdEncoding.DecodeString(enc)
	if err != nil {
		return "", err
	}

	block, err := aes.NewCipher(key)
	if err != nil {
		return "", err
	}

	iv := data[:aes.BlockSize]
	data = data[aes.BlockSize:]

	mode := cipher.NewCBCDecrypter(block, iv)
	mode.CryptBlocks(data, data)

	data = unpad(data)
	return string(data), nil
}

// ===== SAMPLE USAGE =====
func main() {
	apiKey := "your-api-key"
	voucher := "PROMO2026"

	// encrypt
	encrypted, _ := Encrypt(voucher, apiKey)
	fmt.Println("Encrypted voucher:", encrypted)

	// decrypt
	decrypted, _ := Decrypt(encrypted, apiKey)
	fmt.Println("Decrypted voucher:", decrypted)
}
